# code2map 仕様書

## 1. 概要

code2map は、大規模なソースコードファイルを意味的な単位（クラス・メソッド・関数）に分割し、AI によるコードレビューや解析を支援するための「意味的マップ」を生成する CLI ツールである。

### 1.1 背景と目的

大規模なソースコードファイル（数千行規模）を AI でレビューする際、以下の課題が存在する：

- **コンテキスト制限**: AI モデルには入力トークン数の制限があり、巨大なファイル全体を一度に処理できない
- **構造把握の困難**: 長大なコードでは全体構造の把握が困難で、レビュー精度が低下する
- **参照の非効率性**: 特定のメソッドやクラスを参照する際、ファイル全体を読み直す必要がある

code2map はこれらの課題を解決するため、以下を提供する：

1. **構造化された索引（INDEX.md）**: コード全体の見取り図として機能し、シンボル間の関係性を把握可能にする
2. **分割されたコード片（parts/）**: 個別のシンボルを独立したファイルとして抽出し、焦点を絞ったレビューを可能にする
3. **機械可読な対応表（MAP.json）**: ツール連携や差分検知のための構造化データを提供する

### 1.2 設計思想

- **レビュー指向**: 分割されたコードはコンパイル・実行を目的としない。読みやすさと参照性を最優先とする
- **静的解析ベース**: AST（抽象構文木）に基づく解析を行い、正規表現による簡易解析は避ける
- **ヒューリスティック許容**: 呼び出し関係や副作用の検出は完全な正確性を保証しないが、実用的な情報を提供する
- **段階的拡張**: MVP（Minimum Viable Product）として単一ファイル解析から開始し、将来的にディレクトリ・プロジェクト単位の解析に拡張する

---

## 2. 機能要件

### 2.1 入力仕様

| 項目 | 仕様 |
|------|------|
| 対象ファイル | 単一のソースコードファイル |
| 対応言語 | Python（`.py`）、Java（`.java`） |
| エンコーディング | UTF-8（BOM なし）を前提 |
| 想定サイズ | 数百行から数千行（2000 行以上の大規模ファイルを想定） |

**スコープ制限（MVP）**:
- 単一ファイルのみを対象とする
- ディレクトリ単位・複数ファイル一括処理は将来拡張として扱う

### 2.2 出力仕様

ツールは指定された出力ディレクトリに以下の 3 種類の成果物を生成する。

#### 2.2.1 INDEX.md

人間および AI 向けの索引ファイル。Markdown 形式で記述される。

**構成要素**:
- ファイルヘッダ（元ファイル名）
- 警告セクション（パースエラー等がある場合）
- シンボルセクション（Classes / Methods / Functions）

**各シンボルの記載項目**:

| 項目 | 説明 |
|------|------|
| シンボル名 | クラス名、メソッド名（`ClassName#methodName` 形式）、関数名 |
| 行範囲 | 開始行と終了行（`L開始–L終了` 形式） |
| 分割ファイルリンク | parts/ 内の対応ファイルへの相対パス |
| role | Docstring / Javadoc から抽出した役割説明（最初の文） |
| calls | シンボル内で呼び出している他のメソッド・関数の一覧 |
| side effects | 検出された副作用（I/O、DB、ネットワーク等） |

**role / calls / side effects は情報が存在する場合のみ記載し、空の場合は省略する。**

#### 2.2.2 parts/ ディレクトリ

分割されたソースコード片を格納するディレクトリ。

**ファイル命名規則**:

| シンボル種別 | 命名パターン |
|-------------|-------------|
| クラス | `<ClassName>.class.<ext>` |
| メソッド | `<ClassName>_<methodName>.<ext>` |
| トップレベル関数 | `<functionName>.<ext>` |
| ネストクラス | `<OuterClass>_<InnerClass>.class.<ext>` |

**名前衝突の回避**:
- Java のメソッドオーバーロード等で同名シンボルが存在する場合、シグネチャまたは表示名の SHA-256 ハッシュ先頭 4 文字を付与する
- 例：`Foo_doWork__a1b2.java`

**各ファイルのヘッダ**:
- ファイル先頭にメタデータをコメント形式で付与する
- 言語に応じたコメント記法を使用（Python: `#`、Java: `//`）
- 「非ビルド用」である旨の注意書きを含める

**ヘッダに含まれる情報**:
- 元ファイルパス
- 行範囲（開始行-終了行）
- シンボル名
- 参照情報（依存モジュール、呼び出し先）

#### 2.2.3 MAP.json

機械可読な対応表。JSON 配列形式で記述される。

**各エントリのフィールド**:

| フィールド | 型 | 説明 |
|-----------|------|------|
| symbol | string | シンボルの表示名 |
| type | string | シンボル種別（"class" / "method" / "function"） |
| original_file | string | 元ファイル名 |
| original_start_line | integer | 開始行番号（1-based） |
| original_end_line | integer | 終了行番号（inclusive） |
| part_file | string | 分割ファイルの相対パス |
| checksum | string | コード片の SHA-256 チェックサム |

**checksum の算出対象**:
- 分割ファイル全体（ヘッダコメントを含む）の内容を SHA-256 でハッシュ化
- 16 進数文字列（小文字、64 文字）として格納

### 2.3 CLI 仕様

#### 2.3.1 コマンド構文

```
code2map build <input_file> [OPTIONS]
```

#### 2.3.2 引数・オプション

| 引数/オプション | 必須 | デフォルト | 説明 |
|----------------|------|-----------|------|
| `input_file` | 必須 | - | 解析対象のソースファイルパス |
| `--out <DIR>` | 任意 | `./code2map-out` | 出力ディレクトリパス |
| `--lang {java,python}` | 任意 | 自動検出 | 言語の明示指定 |
| `--verbose` | 任意 | false | 詳細ログ出力の有効化 |
| `--dry-run` | 任意 | false | ファイル書き込みを行わずプレビューのみ |

#### 2.3.3 言語自動検出

`--lang` が省略された場合、ファイル拡張子から言語を判定する。

| 拡張子 | 言語 |
|--------|------|
| `.py` | Python |
| `.java` | Java |

上記以外の拡張子の場合はエラーとし、`--lang` オプションでの明示指定を促す。

#### 2.3.4 終了コード

| コード | 意味 |
|--------|------|
| 0 | 正常終了（警告なし） |
| 1 | 致命的エラー（ファイル不在、言語判定不可、パース失敗等） |
| 2 | 部分成功（警告ありだが出力は生成） |

#### 2.3.5 `--dry-run` 時の出力

ファイル書き込みを行わず、以下を標準出力に表示する：
- 検出したシンボル一覧（名前、種別、行範囲）
- 生成予定のファイル一覧

警告がある場合は標準エラー出力に出力する。

#### 2.3.6 出力ディレクトリの動作

| 状況 | 動作 |
|------|------|
| 出力ディレクトリが存在しない | 自動作成する |
| 出力ディレクトリが既に存在 | 既存ファイルを上書きする |
| parts/ サブディレクトリ | 同様に上書き動作 |

**注意**: code2map が生成しないファイル（ユーザーが手動配置したファイル等）は削除しない。

---

## 3. 処理フロー

### 3.1 全体フロー

```
入力ファイル受付
    ↓
言語判定（自動検出 or 明示指定）
    ↓
パーサー選択（Python AST / Java javalang）
    ↓
ソースコード解析 → シンボルリスト + 警告
    ↓
[dry-run?] → Yes → プレビュー出力して終了
    ↓ No
出力ディレクトリ作成
    ↓
parts/ 生成（コード片ファイル作成）
    ↓
INDEX.md 生成（索引ファイル作成）
    ↓
MAP.json 生成（対応表作成）
    ↓
終了（終了コード設定）
```

### 3.2 シンボル抽出フェーズ

パーサーはソースコードを AST に変換し、以下の情報を持つシンボルオブジェクトを抽出する。

**抽出対象**:
- クラス（トップレベル・ネスト）
- メソッド（インスタンスメソッド・クラスメソッド）
- 関数（トップレベルのみ、ネスト関数は親に含める）
- コンストラクタ（Java の場合、`<init>` として扱う）

**抽出情報**:

| 情報 | 説明 |
|------|------|
| 名前 | シンボルの識別名 |
| 種別 | class / method / function |
| 行範囲 | 開始行・終了行（1-based、inclusive） |
| 親シンボル | メソッドの所属クラス、ネストクラスの外部クラス |
| 修飾名 | 階層を含む完全名（例：`Parent.Child`） |
| 役割説明 | Docstring / Javadoc から抽出 |
| 呼び出し先 | コード内で検出した関数・メソッド呼び出し |
| 依存モジュール | import 文から抽出 |

### 3.3 コード片生成フェーズ

シンボルごとに以下の処理を行う：

1. **ファイル名決定**: 命名規則に従いファイル名を生成、衝突時はハッシュ付与
2. **コード抽出**: 元ファイルから該当行範囲を抽出
3. **ヘッダ生成**: メタデータをコメント形式で作成
4. **ファイル書き出し**: ヘッダ + コードを結合して出力

### 3.4 索引生成フェーズ

シンボルリストを基に INDEX.md を生成する。

**副作用検出**:
- 抽出したコード片に対してキーワードマッチングを実行
- 検出カテゴリ：ファイル I/O、標準出力、ログ出力、ネットワーク、DB、例外送出

### 3.5 対応表生成フェーズ

シンボルリストと生成済み parts/ ファイルの情報を基に MAP.json を生成する。

**チェックサム計算**:
- 各分割ファイルの内容全体を SHA-256 でハッシュ化
- 変更検知やキャッシュ管理に利用可能

---

## 4. 言語別対応範囲

### 4.1 Python

**解析基盤**: 標準ライブラリ `ast` モジュール

**対応構文**:

| 構文要素 | 対応状況 |
|---------|---------|
| クラス定義 | 対応（トップレベル・ネスト） |
| 関数定義 | 対応（トップレベルのみ分割対象） |
| メソッド定義 | 対応 |
| デコレータ | 認識（シンボルには含めない） |
| ネスト関数 | 親関数に含める（個別分割しない） |
| 非同期関数 | 対応 |

**メタデータ抽出**:
- Docstring：関数・クラス直下の文字列リテラルを取得、最初の行を role として使用
- 呼び出し関係：`ast.Call` ノードを走査して関数・メソッド呼び出しを抽出
- 依存関係：`import` / `from ... import` 文を解析

**制限事項**:
- 動的呼び出し（`eval`、`exec`、`getattr` による呼び出し）は検出不可
- 型アノテーションの詳細解析は行わない

### 4.2 Java

**解析基盤**: `javalang` ライブラリ

**対応構文**:

| 構文要素 | 対応状況 |
|---------|---------|
| クラス定義 | 対応（トップレベル・ネスト） |
| インターフェース定義 | 対応 |
| メソッド定義 | 対応 |
| コンストラクタ | 対応（`<init>` として扱う） |
| フィールド | 認識（シンボルとしては分割しない） |
| ネストクラス | 対応（`Outer_Inner` 形式で命名） |

**メタデータ抽出**:
- Javadoc：`/** ... */` コメントを取得、最初の文（ピリオドまたは改行まで）を role として使用
- 呼び出し関係：メソッド呼び出しノードを走査
- 依存関係：`import` 文を解析

**行範囲の決定**:
- `javalang` は終了行を提供しないため、ブレース（`{}`）のマッチングにより終了行を算出

**制限事項**:
- アノテーションの詳細解析は行わない
- ジェネリクス型パラメータの完全なマッピングは行わない
- リフレクションによる呼び出しは検出不可

---

## 5. 制約とヒューリスティック

### 5.1 分割コードの非実行性

- 分割されたコード片はコンパイル・実行を目的としない
- import 文の補完や依存解決は行わない
- ファイルヘッダに「非ビルド用」である旨を明記する

### 5.2 依存解析の限界

**calls（呼び出し関係）** と **side effects（副作用）** はヒューリスティックによる推定であり、以下の限界がある：

- 動的ディスパッチ（ポリモーフィズム）は考慮しない
- リフレクションによる呼び出しは検出不可
- 間接的な呼び出し（コールバック、イベント等）は検出不可

### 5.3 副作用検出キーワード

副作用は以下のカテゴリとキーワードパターンで検出する。

| カテゴリ | 検出対象キーワード例 |
|---------|---------------------|
| ファイル I/O | `open(`, `write`, `FileWriter`, `OutputStream` |
| 標準出力 | `print(`, `System.out` |
| ログ出力 | `logging.`, `logger.`, `log.` |
| ネットワーク | `http`, `socket`, `requests.`, `urllib` |
| DB 操作 | `execute`, `cursor`, `jdbc`, `save`, `commit` |
| 例外送出 | `raise`, `throw` |

**注意**: キーワードリストは固定（MVP）。将来的にユーザーカスタマイズ対応を検討する。

### 5.4 ネスト構造の扱い

**ネストクラス**:
- 個別のシンボルとして分割対象
- 命名規則：`OuterClass_InnerClass`
- 修飾名で階層関係を保持

**ネスト関数（Python）**:
- 親関数のシンボルに含める
- 個別ファイルへの分割は行わない
- 理由：ネスト関数は通常、親関数のスコープ内でのみ意味を持つため

---

## 6. エラーハンドリング

### 6.1 パースエラー時の動作

**方針**: 可能な限り部分的な出力を生成する

| 状況 | 動作 |
|------|------|
| 構文エラー検出 | 警告を記録し、抽出済みシンボルで出力生成を試行 |
| 完全なパース失敗 | 空のシンボルリストで出力生成（空の INDEX.md 等） |

**警告の記録先**:
- INDEX.md：`[WARNING]` コメントとして記載
- 標準エラー出力：`--verbose` 時に詳細を出力
- MAP.json：警告情報は含めない（スキーマ固定を優先）

### 6.2 ファイル I/O エラー

| エラー種別 | 動作 |
|-----------|------|
| 入力ファイル不存在 | エラーメッセージ出力、終了コード 1 |
| 出力ディレクトリ書き込み不可 | エラーメッセージ出力、終了コード 1 |
| エンコーディングエラー | 警告出力、置換文字（U+FFFD）で継続処理 |

### 6.3 エンコーディング処理

- 入力ファイルは UTF-8 を前提とする
- 非 UTF-8 文字は置換文字（`\ufffd`）に変換して処理を継続
- 置換が発生した場合は警告を出力

---

## 7. 非機能要件

### 7.1 パフォーマンス

- 数千行のファイルを数秒以内で処理可能であること
- メモリ効率を考慮し、必要に応じてストリーム処理を採用

### 7.2 拡張性

- 新言語対応は、パーサーモジュールの追加で実現可能なアーキテクチャとする
- パーサーは共通インターフェース（基底クラス）を継承する
- 将来的に Tree-sitter への移行を視野に入れた設計とする

### 7.3 動作環境

| 項目 | 要件 |
|------|------|
| Python バージョン | 3.9 以上 |
| 外部依存 | `javalang` ライブラリ（Java パース用） |
| OS | クロスプラットフォーム（Windows / macOS / Linux） |

---

## 8. 将来拡張

以下の機能は MVP 以降のフェーズで対応を検討する。

| 機能 | 概要 |
|------|------|
| 複数ファイル対応 | ディレクトリ単位での一括解析 |
| 新言語追加 | JavaScript、TypeScript、Go、Rust、C++ |
| Tree-sitter 移行 | パフォーマンス・精度向上のための解析基盤変更 |
| 設定ファイル | 分割粒度、キーワードリストのカスタマイズ |
| 差分解析 | 前回出力との比較、変更箇所の検出 |
| CI/CD 統合 | GitHub Actions 等での自動実行サポート |

---

## 付録 A: 出力フォーマット例

### A.1 INDEX.md の構造

```markdown
# Index: <ファイル名>

[WARNING] <警告メッセージ（存在する場合）>

## Classes
- <ClassName> (L開始–L終了) → parts/<ClassName>.class.<ext>
  - role: <役割説明>
  - calls: <呼び出し先一覧>
  - side effects: <副作用一覧>

## Methods
- <ClassName>#<methodName> (L開始–L終了) → parts/<ClassName>_<methodName>.<ext>
  - role: <役割説明>
  - calls: <呼び出し先一覧>
  - side effects: <副作用一覧>

## Functions
- <functionName> (L開始–L終了) → parts/<functionName>.<ext>
  - role: <役割説明>
  - calls: <呼び出し先一覧>
  - side effects: <副作用一覧>
```

### A.2 分割ファイルヘッダの構造

```
<コメント記号> code2map fragment (non-buildable)
<コメント記号> original: <元ファイルパス>
<コメント記号> lines: <開始行>-<終了行>
<コメント記号> symbol: <シンボル表示名>
<コメント記号> notes: references <依存一覧>; calls <呼び出し一覧>

<元のソースコード>
```

### A.3 MAP.json の構造

```json
[
  {
    "symbol": "<シンボル表示名>",
    "type": "<class|method|function>",
    "original_file": "<元ファイル名>",
    "original_start_line": <開始行>,
    "original_end_line": <終了行>,
    "part_file": "parts/<分割ファイル名>",
    "checksum": "<SHA-256ハッシュ値>"
  }
]
```
